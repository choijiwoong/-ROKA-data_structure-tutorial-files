# 쉽게 설명한 퀵 정렬
# 입력: 리스트 a
# 출력: 정렬된 새 리스트

def quick_sort(a):
    n = len(a)
    # 종료 조건: 정렬할 리스트의 자료 개수가 한 개 이하이면 정렬할 필요가 없음
    if n <= 1:
        return a
    # 기준 값을 정하고 기준에 맞춰 그룹을 나누는 과정
    pivot = a[-1]  # 편의상 리스트의 마지막 값을 기준 값으로 정함
    g1 = []        # 그룹 1: 기준 값보다 작은 값을 담을 리스트
    g2 = []        # 그룹 2: 기준 값보다 큰 값을 담을 리스트
    for i in range(0, n - 1):  # 마지막 값은 기준 값이므로 제외
        if a[i] < pivot:       # 기준 값과 비교
            g1.append(a[i])    # 작으면 g1에 추가
        else:
            g2.append(a[i])    # 크면 g2에 추가
    # 각 그룹에 대해 재귀 호출로 퀵 정렬을 한 후
    # 기준 값과  합쳐 하나의 리스트로 결괏값 반환
    return quick_sort(g1) + [pivot] + quick_sort(g2)

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
print(quick_sort(d))


# 퀵 정렬
# 입력: 리스트 a
# 출력: 없음(입력으로 주어진 a가 정렬됨)
# 리스트 a에서 어디부터(start) 어디까지(end)가 정렬 대상인지
# 범위를 지정하여 정렬하는 재귀 호출 함수

def quick_sort_sub(a, start, end):
    # 종료 조건: 정렬 대상이 한 개 이하이면 정렬할 필요가 없음
    if end - start <= 0:
        return
    # 기준 값을 정하고 기준 값에 맞춰 리스트 안에서 각 자료의 위치를 맞춤
    # [기준 값보다 작은 값들, 기준 값, 기준 값보다 큰 값들]
    pivot = a[end]   # 편의상 리스트의 마지막 값을 기준 값으로 정함_***만약 이 값이 가장 작은 값(or 가장 큰 값)이면 효율이 떨어짐.
    #그래서 퀵정렬 사용 시 좋은 기준값을 정하는 것은 전반적인 정렬의 효율성을 결정. 이는 굉장히 복잡한 내용.
    i = start
    for j in range(start, end):
        if a[j] <= pivot:
            a[i], a[j] = a[j], a[i]
            i += 1
    a[i], a[end] = a[end], a[i]#편의상 기준값을 끝값으로 잡은 것 복구
    # 재귀 호출 부분
    quick_sort_sub(a, start, i - 1) # 기준 값보다 작은 그룹을 재귀 호출로 다시 정렬
    quick_sort_sub(a, i + 1, end)  # 기준 값보다 큰 그룹을 재귀 호출로 다시 정렬

# 리스트 전체(0 ~ len(a) -1)를 대상으로 재귀 호출 함수 호출
def quick_sort_(a):
    quick_sort_sub(a, 0, len(a) - 1)

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
quick_sort_(d)
print(d)

#최악의 경우 O(n^2)이지만, 평균적일 경우 병합 정렬과 같은 O(n*logn)
#but 좋은 기준을 정하는 알고리즘이 많이 연구되어 대부분 O(n*logn)으로 정렬마칠 수 있음.


"""정렬 정리
선택정렬(selection sort): (아직 정렬하지 않은)남은 자료중에 최솟값을 뽑아 차례로 배치(앞에서부터)->O(n^2)
삽입정렬(insert sort): (새 리스트를 만들어)자료를 하나씩 적절한 위치(새 리스트에 알맞은 위치로)에 삽입->보통 O(n^2)
병합정렬(merge sort): 그룹을 나누어 각각 정렬(재귀호출사용)->(새리스트를 만들어 알맞은 위치로) 병합->O(n*long)
퀵정렬(quick sort): 기준선택->기준에 맞추어 그룹을 나누기->그룹별로 정렬(재귀호출)->보통 O(n*logn)
거품정렬(bubble sort): 앞뒤로 이웃한 자료를 비교->크기가 뒤집힌 경우 서로 위치를 바꿈->보통 O(n^2)

파이썬 모듈의 sorted(list) OR a.sort()는 병합정렬과 삽입정렬을 섞어 만든 새로운 정렬 알고리즘을 사용. 평균적으로 O(n*logn)의 복잡도.

"""

"""계산복잡도정리
O(1): 입력 크기 n과 계산 복잡도가 무관할 때_1~n까지의 합->공식n(n+1)/2 사용하여 n과 무관하게 일정
O(logn): 입력크기n이 로그값에 비례_이분탐색
O(n): 입력크기n과 비례_최댓값찾기, 순차탐색
O(n*logn):n*logn과 비례_병합정렬, 퀵정렬
O(n^2): n^2에 비례_선택정렬, 삽입정렬
O(2^n): 2^n비례_하노이의 탑
"""
